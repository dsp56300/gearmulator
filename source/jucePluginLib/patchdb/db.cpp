#include "db.h"

#include <cassert>

#include "datasource.h"
#include "patch.h"
#include "patchmodifications.h"

#include "../../synthLib/os.h"
#include "../../synthLib/midiToSysex.h"

#include "dsp56kEmu/logging.h"

namespace pluginLib::patchDB
{
	DB::DB(juce::File _dir)
	: m_settingsDir(std::move(_dir))
	, m_jsonFileName(m_settingsDir.getChildFile("patchmanagerdb.json"))
	, m_loader("PatchLoader", false, dsp56k::ThreadPriority::Lowest)
	{
	}

	DB::~DB()
	{
		assert(m_loader.destroyed() && "stopLoaderThread() needs to be called by derived class in destructor");
		stopLoaderThread();
	}

	void DB::addDataSource(const DataSource& _ds)
	{
		const auto ds = std::make_shared<DataSourceNode>(_ds);

		runOnLoaderThread([this, ds]
		{
			addDataSource(ds);
			saveJson();
		});
	}

	void DB::removeDataSource(const DataSource& _ds)
	{
		runOnLoaderThread([this, _ds]
		{
			std::unique_lock lockDs(m_dataSourcesMutex);

			const auto it = m_dataSources.find(_ds);
			if (it == m_dataSources.end())
				return;

			const auto ds = it->second;

			// if a DS is removed that is of type Manual and it has a parent, switch it to Autogenerated but don't remove it
			if (ds->origin == DataSourceOrigin::Manual && ds->hasParent())
			{
				ds->origin = DataSourceOrigin::Autogenerated;

				std::unique_lock lockUi(m_uiMutex);
				m_dirty.dataSources = true;
				return;
			}

			std::set<DataSourceNodePtr> removedDataSources{it->second};

			// remove all datasources that are a child of the one being removed
			std::function<void(const DataSourceNodePtr&)> removeChildren = [&](const DataSourceNodePtr& _parent)
			{
				for (auto& child : _parent->getChildren())
				{
					const auto c = child.lock();

					if (!c || c->origin == DataSourceOrigin::Manual)
						continue;

					removedDataSources.insert(c);
					removeChildren(c);
				}
			};

			removeChildren(ds);

			for (const auto& removed : removedDataSources)
				m_dataSources.erase(*removed);

			lockDs.unlock();

			// remove all patches that were added due to this datasource
			std::vector<PatchKey> removedPatches;

			{
				std::unique_lock lockPatches(m_patchesMutex);

				for (auto itPatch = m_patches.begin(); itPatch != m_patches.end();)
				{
					const auto& patch = itPatch->second;

					if (removedDataSources.find(patch->source) != removedDataSources.end())
					{
						removedPatches.push_back(itPatch->first);
						m_patches.erase(itPatch++);
					}
					else
					{
						++itPatch;
					}
				}
			}

			const auto patchesChanged = !removedPatches.empty();

			removePatchesFromSearches(removedPatches);

			{
				std::unique_lock lockUi(m_uiMutex);

				m_dirty.dataSources = true;
				if (patchesChanged)
					m_dirty.patches = true;
			}

			for (auto& removedDataSource : removedDataSources)
			{
				if (removedDataSource->name == "F:\\AccessVirusEmulator\\Presets")
					int foo = 0;
				removedDataSource->setParent(nullptr);
				removedDataSource->removeAllChildren();
			}
			removedDataSources.clear();

			saveJson();
		});
	}

	void DB::refreshDataSource(const DataSourceNodePtr& _ds)
	{
	}

	bool DB::addTag(const TagType _type, const std::string& _tag)
	{
		{
			std::unique_lock lock(m_patchesMutex);
			if (!internalAddTag(_type, _tag))
				return false;
		}
		saveJson();
		return true;
	}

	bool DB::removeTag(TagType _type, const Tag& _tag)
	{
		{
			std::unique_lock lock(m_patchesMutex);
			if (!internalRemoveTag(_type, _tag))
				return false;
		}
		saveJson();
		return true;
	}

	void DB::uiProcess(Dirty& _dirty)
	{
		std::list<std::function<void()>> uiFuncs;
		{
			std::scoped_lock lock(m_uiMutex);
			std::swap(uiFuncs, m_uiFuncs);
			_dirty = m_dirty;
			m_dirty = {};
		}

		for (const auto& func : uiFuncs)
			func();
	}

	uint32_t DB::search(SearchRequest&& _request, std::function<void(const SearchResult&)>&& _callback)
	{
		const auto handle = m_nextSearchHandle++;

		auto s = std::make_shared<Search>();

		s->handle = handle;
		s->request = std::move(_request);
		s->callback = std::move(_callback);

		std::scoped_lock lock(m_searchesMutex);
		m_searches.insert({ s->handle, s });

		runOnLoaderThread([this, s]
		{
			executeSearch(*s);
		});

		return handle;
	}

	void DB::cancelSearch(const uint32_t _handle)
	{
		std::unique_lock lock(m_searchesMutex);
		m_cancelledSearches.insert(_handle);
		m_searches.erase(_handle);
	}

	std::shared_ptr<Search> DB::getSearch(const SearchHandle _handle)
	{
		std::unique_lock lock(m_searchesMutex);
		const auto it = m_searches.find(_handle);
		if (it == m_searches.end())
			return {};
		return it->second;
	}

	void DB::getTags(const TagType _type, std::set<Tag>& _tags)
	{
		_tags.clear();

		std::shared_lock lock(m_patchesMutex);
		const auto it = m_tags.find(_type);
		if (it == m_tags.end())
			return;

		_tags = it->second;
	}

	bool DB::modifyTags(const std::vector<PatchPtr>& _patches, const TypedTags& _tags)
	{
		std::vector<PatchPtr> changed;
		changed.reserve(_patches.size());

		std::unique_lock lock(m_patchesMutex);

		for (const auto& patch : _patches)
		{
			const auto key = PatchKey(*patch);

			const auto& itPatch = m_patches.find(key);
			if (itPatch == m_patches.end())
				return false;

			const auto& it = m_patchModifications.find(key);

			if (it != m_patchModifications.end())
			{
				if (it->second->modifyTags(_tags))
					changed.push_back(patch);

				continue;
			}

			const auto mods = std::make_shared<PatchModifications>();
			mods->patch = itPatch->second;

			if (!mods->modifyTags(_tags))
				continue;

			itPatch->second->modifications = mods;

			m_patchModifications.insert({ key, mods });

			changed.push_back(patch);
		}

		if(!changed.empty())
			updateSearches(changed);

		lock.unlock();

		if(!changed.empty())
			saveJson();

		return true;
	}

	bool DB::loadData(DataList& _results, const DataSourceNodePtr& _ds)
	{
		switch (_ds->type)
		{
		case SourceType::Rom:
			return loadRomData(_results, _ds->bank, g_invalidProgram);
		case SourceType::File:
			return loadFile(_results, _ds->name);
		case SourceType::Invalid:
		case SourceType::Folder:
		case SourceType::Count:
			return false;
		}
		return false;
	}

	bool DB::loadFile(DataList& _results, const std::string& _file)
	{
		Data data;
		data.reserve(16384);

		const auto& file = _file;

		const auto size = synthLib::getFileSize(file);

		// unlikely that a 4mb file has useful data for us, skip
		if (!size || size >= static_cast<size_t>(4 * 1024 * 1024))
			return false;

		if (!synthLib::readFile(data, file) || data.empty())
			return false;

		return parseFileData(_results, data);
	}

	bool DB::loadFolder(const DataSourceNodePtr& _folder)
	{
		assert(_folder->type == SourceType::Folder);

		std::vector<std::string> files;
		synthLib::findFiles(files, _folder->name, {}, 0, 0);

		for (const auto& file : files)
		{
			const auto child = std::make_shared<DataSourceNode>();
			child->setParent(_folder);
			child->name = file;
			child->origin = DataSourceOrigin::Autogenerated;

			if (FILE* hFile = fopen(file.c_str(), "rb"))
			{
				fclose(hFile);  // NOLINT(cert-err33-c) - why? What am I supposed to do if I cannot close a file, eh?

				child->type = SourceType::File;
			}
			else
			{
				child->type = SourceType::Folder;
			}
			addDataSource(child);
		}

		return !files.empty();
	}

	bool DB::parseFileData(DataList& _results, const Data& _data)
	{
		synthLib::MidiToSysex::extractSysexFromData(_results, _data);
		return !_results.empty();
	}

	void DB::startLoaderThread()
	{
		m_loader.start();

		runOnLoaderThread([this]
		{
			loadJson();
		});
	}

	void DB::stopLoaderThread()
	{
		m_loader.destroy();
	}

	void DB::runOnLoaderThread(std::function<void()>&& _func)
	{
		m_loader.add(std::move(_func));
	}

	void DB::runOnUiThread(const std::function<void()>& _func)
	{
		m_uiFuncs.push_back(_func);
	}

	void DB::addDataSource(const DataSourceNodePtr& _ds)
	{
		if (m_loader.destroyed())
			return;

		auto ds = _ds;

		bool dsExists;

		{
			std::unique_lock lockDs(m_dataSourcesMutex);

			const auto itExisting = m_dataSources.find(*ds);

			dsExists = itExisting != m_dataSources.end();

			if (dsExists)
			{
				// two things can happen here:
				// * a child DS already exists and the one being added has a parent that was previously unknown to the existing DS
				// * a DS is added again (for example manually requested by a user) even though it already exists because of a parent DS added earlier

				ds = itExisting->second;

				if(_ds->origin == DataSourceOrigin::Manual)
				{
					// user manually added a DS that already exists as a child
					assert(!_ds->hasParent());
					ds->origin = _ds->origin;
				}
				else if(_ds->hasParent() && !ds->hasParent())
				{
					// a parent datasource is added and this DS previously didn't have a parent
					ds->setParent(_ds->getParent());
				}
				else
				{
					// nothing to be done
					assert(_ds->getParent().get() == ds->getParent().get());
					return;
				}

				std::unique_lock lockUi(m_uiMutex);
				m_dirty.dataSources = true;
			}
		}

		auto addDsToList = [&]
		{
			if (dsExists)
				return;

			std::unique_lock lockDs(m_dataSourcesMutex);

			m_dataSources.insert({ *ds, ds });
			std::unique_lock lockUi(m_uiMutex);
			m_dirty.dataSources = true;

			dsExists = true;
		};

		if (ds->type == SourceType::Folder)
		{
			addDsToList();
			loadFolder(ds);
			return;
		}

		// always add DS if manually requested by user
		if (ds->origin == DataSourceOrigin::Manual)
			addDsToList();

		std::vector<std::vector<uint8_t>> data;

		if(loadData(data, ds) && !data.empty())
		{
			std::vector<PatchPtr> patches;
			patches.reserve(data.size());

			for (uint32_t p = 0; p < data.size(); ++p)
			{
				if (const auto patch = initializePatch(data[p], ds))
				{
					patch->program = p;
					patches.push_back(patch);
				}
			}

			if (!patches.empty())
				addDsToList();

			addPatches(patches);
		}
	}

	bool DB::addPatches(const std::vector<PatchPtr>& _patches)
	{
		if (_patches.empty())
			return false;

		std::unique_lock lock(m_patchesMutex);

		for (const auto& patch : _patches)
		{
			const auto key = PatchKey(*patch);

			if (m_patches.find(key) != m_patches.end())
				continue;

			// find modification and apply it to the patch
			const auto itMod = m_patchModifications.find(key);
			if (itMod != m_patchModifications.end())
			{
				patch->modifications = itMod->second;
				itMod->second->patch = patch;
				itMod->second->updateCache();
			}

			m_patches.insert({ key, patch });

			// add to all known categories, tags, etc
			for (const auto& it : patch->getTags().get())
			{
				const auto type = it.first;
				const auto& tags = it.second;

				for (const auto& tag : tags.getAdded())
					internalAddTag(type, tag);
			}
		}

		// add to ongoing searches
		updateSearches(_patches);

		return true;
	}

	bool DB::removePatch(const PatchKey& _key)
	{
		std::unique_lock lock(m_patchesMutex);

		const auto it = m_patches.find(_key);
		if (it == m_patches.end())
			return false;

		m_patches.erase(it);

		removePatchesFromSearches({ _key });

		std::unique_lock lockUi(m_uiMutex);
		m_dirty.patches = true;

		return true;
	}

	bool DB::internalAddTag(TagType _type, const Tag& _tag)
	{
		const auto itType = m_tags.find(_type);

		if (itType == m_tags.end())
		{
			m_tags.insert({ _type, {_tag} });

			std::unique_lock lockUi(m_uiMutex);
			m_dirty.tags.insert(_type);
			return true;
		}

		auto& tags = itType->second;

		if (tags.find(_tag) != tags.end())
			return false;

		tags.insert(_tag);
		std::unique_lock lockUi(m_uiMutex);
		m_dirty.tags.insert(_type);

		return true;
	}

	bool DB::internalRemoveTag(const TagType _type, const Tag& _tag)
	{
		const auto& itType = m_tags.find(_type);

		if (itType == m_tags.end())
			return false;

		auto& tags = itType->second;
		const auto itTag = tags.find(_tag);

		if (itTag == tags.end())
			return false;

		tags.erase(itTag);

		std::unique_lock lockUi(m_uiMutex);
		m_dirty.tags.insert(_type);

		return true;
	}

	bool DB::executeSearch(Search& _search)
	{
		_search.state = SearchState::Running;

		std::shared_lock patchesLock(m_patchesMutex);

		for (const auto& [key, patchPtr] : m_patches)
		{
			if (m_cancelledSearches.find(_search.handle) != m_cancelledSearches.end())
			{
				_search.state = SearchState::Cancelled;
				std::unique_lock lockUi(m_uiMutex);
				m_dirty.searches.insert(_search.handle);
				return false;
			}

			const auto* patch = patchPtr.get();
			assert(patch);

			if(_search.request.match(*patch))
			{
				std::unique_lock searchLock(_search.resultsMutex);
				_search.results.insert({ key, patchPtr });
			}
		}

		{
			_search.state = SearchState::Completed;
			std::unique_lock lockUi(m_uiMutex);
			m_dirty.searches.insert(_search.handle);
		}

		return true;
	}

	void DB::updateSearches(const std::vector<PatchPtr>& _patches)
	{
		std::unique_lock lockSearches(m_searchesMutex);

		std::set<SearchHandle> dirtySearches;

		std::vector<PatchKey> keys;
		keys.reserve(_patches.size());
		for (const auto& patch : _patches)
			keys.emplace_back(*patch);

		for (const auto& it : m_searches)
		{
			const auto handle = it.first;
			auto& search = it.second;

			bool searchDirty = false;

			for(size_t i=0; i<keys.size(); ++i)
			{
				const auto& key = keys[i];
				const auto& patch = _patches[i];

				const auto match = search->request.match(*patch);

				bool countChanged;

				{
					std::unique_lock lock(search->resultsMutex);
					const auto oldCount = search->results.size();

					if (match)
						search->results.insert({ key, patch });
					else
						search->results.erase(key);

					const auto newCount = search->results.size();
					countChanged = newCount != oldCount;
				}

				if (countChanged)
					searchDirty = true;
			}
			if (searchDirty)
				dirtySearches.insert(handle);
		}

		if (dirtySearches.empty())
			return;

		std::unique_lock lockUi(m_uiMutex);

		for (SearchHandle dirtySearch : dirtySearches)
			m_dirty.searches.insert(dirtySearch);
	}

	bool DB::removePatchesFromSearches(const std::vector<PatchKey>& _keys)
	{
		bool res = false;

		std::scoped_lock lockSearches(m_searchesMutex);

		for (auto& itSearches : m_searches)
		{
			const auto& search = itSearches.second;

			bool countChanged;
			{
				std::unique_lock lockResults(search->resultsMutex);
				const auto oldCount = search->results.size();

				for (const auto& key : _keys)
					search->results.erase(key);

				const auto newCount = search->results.size();
				countChanged = newCount != oldCount;
			}

			if (countChanged)
			{
				res = true;
				std::unique_lock lockUi(m_uiMutex);
				m_dirty.searches.insert(itSearches.first);
			}
		}
		return res;
	}

	bool DB::loadJson()
	{
		bool success = true;

		const auto json = juce::JSON::parse(m_jsonFileName);
		const auto* datasources = json["datasources"].getArray();

		if(datasources)
		{
			for(int i=0; i<datasources->size(); ++i)
			{
				const auto var = datasources->getUnchecked(i);

				DataSource ds;

				ds.type = toSourceType(var["type"].toString().toStdString());
				ds.name = var["name"].toString().toStdString();
				ds.origin = DataSourceOrigin::Manual;

				if (ds.type != SourceType::Invalid && !ds.name.empty())
				{
					addDataSource(ds);
				}
				else
				{
					LOG("Unexpected data source type " << toString(ds.type) << " with name '" << ds.name << "'");
					success = false;
				}
			}
		}

		{
			std::unique_lock lockPatches(m_patchesMutex);

			auto* tags = json["tags"].getDynamicObject();

			if(tags)
			{
				const auto& props = tags->getProperties();
				for (const auto& it : props)
				{
					const auto strType = it.name.toString().toStdString();
					const auto type = toTagType(strType);

					const auto* tagsArray = it.value.getArray();
					if(tagsArray)
					{
						std::set<Tag> newTags;
						for(int i=0; i<tagsArray->size(); ++i)
						{
							const auto tag = tagsArray->getUnchecked(i).toString().toStdString();
							newTags.insert(tag);
						}
						m_tags.insert({ type, newTags });
						m_dirty.tags.insert(type);
					}
					else
					{
						LOG("Unexpected empty tags for tag type " << strType);
						success = false;
					}
				}
			}

			auto* patches = json["patches"].getDynamicObject();

			if (patches)
			{
				const auto& props = patches->getProperties();
				for (const auto& it : props)
				{
					const auto strKey = it.name.toString().toStdString();
					const auto var = it.value;

					auto key = PatchKey::fromString(strKey);

					PatchModificationsPtr mods = std::make_shared<PatchModifications>();

					if (!mods->deserialize(var))
					{
						LOG("Failed to parse patch modifications for key " << strKey);
						success = false;
						continue;
					}

					if(!key.isValid())
					{
						LOG("Failed to parse patch key from string " << strKey);
						success = false;
					}

					m_patchModifications.insert({ key, mods });
				}
			}
		}

		return success;
	}

	bool DB::saveJson()
	{
		if (!m_jsonFileName.hasWriteAccess())
			return false;
		const auto tempFile = juce::File(m_jsonFileName.getFullPathName() + "_tmp.json");
		if (!tempFile.hasWriteAccess())
			return false;

		auto* json = new juce::DynamicObject();

		{
			std::shared_lock lockDs(m_dataSourcesMutex);

			juce::Array<juce::var> dss;

			for (const auto& it : m_dataSources)
			{
				const auto& dataSource = it.second;

				if (dataSource->origin != DataSourceOrigin::Manual)
					continue;

				if (dataSource->type == SourceType::Rom)
					continue;

				auto* o = new juce::DynamicObject();

				o->setProperty("type", juce::String(toString(dataSource->type)));
				o->setProperty("name", juce::String(dataSource->name));

				dss.add(o);
			}
			json->setProperty("datasources", dss);
		}

		{
			std::shared_lock lockP(m_patchesMutex);

			auto* tagTypes = new juce::DynamicObject();

			for (const auto& it : m_tags)
			{
				const auto type = it.first;
				const auto& tags = it.second;

				if(tags.empty())
					continue;

				juce::Array<juce::var> tagsArray;
				for (const auto& tag : tags)
					tagsArray.add(juce::String(tag));

				tagTypes->setProperty(juce::String(toString(type)), tagsArray);
			}

			json->setProperty("tags", tagTypes);

			auto* patchMods = new juce::DynamicObject();

			for (const auto& it : m_patchModifications)
			{
				const auto& key = it.first;
				const auto& mods = it.second;

				if (mods->empty())
					continue;

				auto* obj = mods->serialize();

				patchMods->setProperty(juce::String(key.toString()), obj);
			}

			json->setProperty("patches", patchMods);
		}

		const auto jsonText = juce::JSON::toString(juce::var(json), false);
		if (!tempFile.replaceWithText(jsonText))
			return false;
		if (!tempFile.copyFileTo(m_jsonFileName))
			return false;
		tempFile.deleteFile();
		return true;
	}
}
