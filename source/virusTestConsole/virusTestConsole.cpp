#include <fstream>
#include <vector>

#include "../dsp56300/source/dsp56kEmu/dsp.h"
#include "../dsp56300/source/dsp56kEmu/unittests.h"

#include "../virusLib/accessVirus.h"
#include "../virusLib/syx.h"

#define HEXN(S, n)                     std::hex << std::setfill('0') << std::setw(n) << S

using namespace dsp56k;

typedef struct Cmd
{
	const char* name;
	uint8_t key;
	uint8_t value;
} Cmd;

std::thread boot_virus_from_file(const AccessVirus& v,DSP& dsp,Peripherals56362& periph)
{
	// Load BootROM in DSP memory
	for (int i=0; i<v.bootRom.data.size(); i++)
		dsp.memory().set(dsp56k::MemArea_P, v.bootRom.offset + i, v.bootRom.data[i]);

//	dsp.memory().saveAssembly("Virus_BootROM.asm", v.bootRom.offset, v.bootRom.size, false, false);

	// Attach command stream
	std::thread feedCommandStream([&]()
	{
		periph.getHDI08().writeRX((int32_t*)&v.commandStream[0],v.commandStream.size());
	});

	// Initialize the DSP
	dsp.setPC(v.bootRom.offset);
	return feedCommandStream;
}


int main(int _argc, char* _argv[])
{
	UnitTests tests;

	// Create the DSP with peripherals
	constexpr TWord g_memorySize = 0x040000;	// 128k words beginning at 0x200000
	const DefaultMemoryMap memoryMap;
	Memory memory(memoryMap, g_memorySize);
	memory.setExternalMemory(0x020000, true);
	Peripherals56362 periph;
	DSP dsp(memory, &periph, &periph);

	const AccessVirus v(_argv[1]);
	std::thread loader = boot_virus_from_file(v, dsp, periph);

//	memory.saveAssembly("Virus_P.asm", 0, g_memorySize, false, true);

	std::thread dspThread([&]()
	{
		while(true)
		{
			dsp.exec();
		}
	});

	std::thread midiThread([&]() {
		int midi[128];
		auto sequenceStarted = false;
		size_t idx = 0;
		while (true) {
			// Only support for single byte responses atm
			uint32_t word = periph.getHDI08().readTX();
			if ((word & 0xff00ffff) != 0) {
				LOG("Unexpected MIDI data: 0x" << HEX(word));
				continue;
			}

			int buf = (word & 0x00ff0000) >> 16;

			// Check for sequence start 0xf0
			if (!sequenceStarted) {
				if (buf == 0 || buf == 0xf5)
					continue;
				if (buf != 0xf0) {
					LOG("Unexpected MIDI bytes: 0x" << HEXN(buf, 2));
					continue;
				}
				sequenceStarted = true;
			}

			midi[idx] = buf;
			++idx;

			// End of midi command, show it
			if (buf == 0xf7) {
				std::ostringstream stringStream;
				for (int i = 0; i < idx; i++) {
					//printf("tmp: 0x%x\n", midi[i]);
					stringStream << HEXN(midi[i], 2);
				}
				LOG("SYSEX RESPONSE: 0x" << stringStream.str());
				memset(midi, 0, sizeof midi);
				sequenceStarted = false;
				idx = 0;
			}

			//LOG("BUF=0x"<< HEX(buf));
		}
	});

	constexpr size_t sampleCount = 4;
	constexpr size_t channelsIn = 2;
	constexpr size_t channelsOut = 6;

	float inputData[channelsIn][sampleCount] = 
	{
		{1,-1,0.5f,-0.5f},
		{1,-1,0.5f,-0.5f},
	};

	float outputData[channelsOut][sampleCount] = 
	{
		{0,0,0,0},
		{0,0,0,0},
		{0,0,0,0},
		{0,0,0,0},
		{0,0,0,0},
		{0,0,0,0}
	};

	float* audioIn [channelsIn ] = {inputData[0], inputData[1]};
	float* audioOut[channelsOut] = {outputData[0], outputData[1], outputData[2], outputData[3], outputData[4], outputData[5]};

	// Make a dummy setup
	int pots[22]={0x1a,0x1b,0x1c,0x1d,0x35,0x36,0x2d,0x4c,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x6a,0x7c,0x7d,0x7e,0x79,0x6d,0x7f};
	int vals[46];
	for (int i=0;i<22;i++) {vals[i*2]=0xf4f472;vals[i*2+1]=(pots[i]<<8)|0x00003f;}
	vals[44]=0xf4f472;vals[45]=0x007f7f;

	// queue for HDI08
	loader.join();

	int off=0,tosend=0;
	int initpatch[270] = {0xF0,0x00,0x20,0x33,0x01,0x10,0x10,0x01,0x06,0x07,0x06,0x00,0x06,0x03,0x07,0x00,0x7F,0x00,0x00,0x40,0x7F,0x00,0x00,0x00,0x00,0x00,0x56,0x00,0x32,0x40,0x60,0x31,0x5A,0x18,0x40,0x00,0x00,0x00,0x40,0x40,0x60,0x00,0x40,0x24,0x1E,0x40,0x5D,0x00,0x3F,0x6C,0x2B,0x1B,0x0B,0x4A,0x4A,0x43,0x00,0x40,0x00,0x00,0x03,0x02,0x01,0x16,0x52,0x1A,0x31,0x45,0x5C,0x50,0x7F,0x40,0x5B,0x00,0x00,0x00,0x07,0x01,0x00,0x00,0x44,0x41,0x00,0x40,0x40,0x29,0x40,0x40,0x17,0x01,0x00,0x00,0x56,0x00,0x00,0x40,0x40,0x40,0x40,0x50,0x6C,0x01,0x40,0x00,0x00,0x00,0x02,0x0F,0x58,0x43,0x00,0x01,0x00,0x60,0x00,0x1F,0x6B,0x35,0x57,0x01,0x00,0x00,0x46,0x3A,0x18,0x10,0x0C,0x01,0x50,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x62,0x00,0x40,0x00,0x6A,0x01,0x00,0x20,0x19,0x00,0x00,0x00,0x00,0x49,0x37,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x01,0x42,0x3E,0x01,0x00,0x01,0x01,0x01,0x24,0x28,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x28,0x40,0x00,0x55,0x00,0x37,0x62,0x5C,0x47,0x3D,0x25,0x40,0x35,0x67,0x15,0x51,0x00,0x40,0x28,0x39,0x5E,0x16,0x09,0x3F,0x17,0x19,0x0C,0x3D,0x2C,0x4E,0x00,0x22,0x62,0x15,0x19,0x23,0x67,0x00,0x40,0x00,0x40,0x00,0x05,0x22,0x24,0x4A,0x3C,0x6A,0x6A,0x00,0x40,0x47,0x33,0x40,0x40,0x5A,0x39,0x00,0x00,0x1C,0x00,0x03,0x00,0x40,0x03,0x00,0x40,0x03,0x00,0x40,0x41,0x6E,0x64,0x72,0x6F,0x6D,0x65,0x64,0x61,0x72,0x00,0x04,0x03,0x02,0x03,0x00,0x6D,0xF7,0x90,0x3c,0x7f};
//	int initpatch[270] = {0xF0,0x00,0x20,0x33,0x01,0x10,0x10,0x00,0x40,0x07,0x00,0x02,0x7E,0x03,0x00,0x00,0x7F,0x00,0x00,0x40,0x7F,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x40,0x60,0x40,0x00,0x00,0x40,0x20,0x00,0x00,0x40,0x40,0x60,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x40,0x7F,0x40,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x00,0x40,0x7F,0x00,0x7F,0x7F,0x40,0x04,0x00,0x00,0x00,0x30,0x01,0x00,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x30,0x01,0x00,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x64,0x01,0x40,0x00,0x00,0x00,0x00,0x30,0x7F,0x40,0x00,0x01,0x00,0x01,0x00,0x45,0x10,0x7F,0x40,0x01,0x00,0x01,0x00,0x40,0x00,0x10,0x0C,0x01,0x40,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x5C,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x39,0x04,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x01,0x42,0x3E,0x01,0x00,0x01,0x01,0x01,0x24,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x28,0x2B,0x55,0x40,0x40,0x40,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x00,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x40,0x00,0x40,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x03,0x00,0x24,0x70,0x30,0x40,0x7F,0x00,0x40,0x47,0x33,0x40,0x40,0x28,0x20,0x00,0x00,0x00,0x00,0x03,0x00,0x40,0x03,0x00,0x40,0x03,0x00,0x40,0x62,0x61,0x73,0x69,0x63,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x01,0x00,0x7F,0x00,0xF7,0x90,0x3c,0x7f};
	for (int i=0;i<270;i++) initpatch[i]=(initpatch[i]<<16);

	FILE* hFile = nullptr;
	int ctr=0,go=0;
	auto bruteidx = 0x73;

	// SYSEX (part a & b)
	std::array<char, 256> values;
	std::ifstream file(_argv[2], std::ios::binary);
	file.seekg(0x9);
	file.read(values.data(), values.size());
//	printf("OSC VOLUME: 0x%x\n", values[0x24]);
//	printf("CHAR = 0x%x\n", values[0xf0]);
//	assert(values[0xf0] == 0x62);
	int bank = 0, param = 0;

	// Part C
	std::vector<Cmd> commands;
	commands.emplace_back(Cmd{"Device ID", 93, 0});
	commands.emplace_back(Cmd{"Part Enable", 72, 1});
	commands.emplace_back(Cmd{"Part MIDI Channel", 34, 0});
	commands.emplace_back(Cmd{"Part Output Select", 41, 0});

	// Part C after A+B are set
	std::vector<Cmd> commandsAfter;
	commandsAfter.emplace_back(Cmd{"Part MIDI Volume Enable", 73, 1});
	commandsAfter.emplace_back(Cmd{"Part MIDI Volume Init", 40, 127});
	commandsAfter.emplace_back(Cmd{"Part Volume", 39, 0x7f});
	commandsAfter.emplace_back(Cmd{"Master Volume", 127, 0x40});
//	commands.emplace_back(Cmd{"Part Prog Change Enable", 78, 1});
//	commands.emplace_back(Cmd{"MIDI Dump Tx", 98, 0});
//	commands.emplace_back(Cmd{"MIDI Dump Rx", 99, 1});
//	commands.emplace_back(Cmd{"MIDI Control Low (SysEx)", 94, 0});
//	commands.emplace_back(Cmd{"MIDI Control High (SysEx)", 95, 0});

	const int delayed_last = 1;
	int cmdIdx = 0, cmdAfterIdx = 0;

	auto t = false;
	auto sethostflag = false;
	auto ready = false;
	auto midisent = false;
	auto superFinal = false;
	while (true)
	{
		ctr++;

		// Only execute a command every 1000 cycles
		if (!ready && ctr > 300 && (ctr % 10) == 0) {
			// Check if we are allowed to send MIDI data
			if (!bittest(periph.getHDI08().readControlRegister(), HDI08::HCR_HRIE)) {
				LOG("TOO EARLY!");
				continue;
			}

			if (!sethostflag) {
				periph.getHDI08().setHostFlags(0, 1);
				LOG("Setted host flag 0 1");
				// Send a MIDI command

//				int data[3] = {0xf330100};
//				periph.getHDI08().writeRX(data, 1);
//				int data[3] = {0x903c7f};
//				periph.getHDI08().writeRX(data, 1);
//				go = true;
//				int data2[3] = {0x803c7f};
//				periph.getHDI08().writeRX(data2, 1);
				sethostflag = true;
			}

			if (ctr > 2000) {
				if (cmdIdx < commands.size()) {
					// Send the initial PART C commands
					auto cmd = commands[cmdIdx];
					printf("Sending PART C command %s: 0x%x=0x%x\n", cmd.name, cmd.key, cmd.value);
					int buf[] = {0xf00040, 0x0000f7};
					buf[0] = buf[0] | (0x72 << 8);
					buf[1] = buf[1] | ((cmd.key % 0x80) << 16) | (cmd.value << 8);
					periph.getHDI08().writeRX(buf, 2);
					cmdIdx++;
				} else if (bank <= 1) {
					// CLEAR Page A & B
	//				for (int tmp = 0; tmp < 3; tmp++) {
	//					while (true) {
	//						if (bank == 0 && (param == 2 || param == 3 || param == 4 || param == 7)) {
	//							// Skip these
	//							param++;
	//							continue;
	//						}
	//						break;
	//					}
						int cmd = 0x70 + bank;
						int buf[] = {0xf00040, 0x0000f7};
						//const int value = values[param];
						const int value = 0x0;
						buf[0] = buf[0] | (cmd << 8);
						buf[1] = buf[1] | ((param % 0x80) << 16) | (value << 8);
						printf("Sending parameter BANK=0x%x KEY=0x%x VALUE=0x%x..\n", cmd, param, value);
						periph.getHDI08().writeRX(buf, 2);
						if ((param % 0x80) == 0x7f) {
							bank++;
							param++;
						}
						param++;
	//				}
				} else {
					// COMPLETE! Send the C after commands to enable sound
					if (cmdAfterIdx < commandsAfter.size()) {
						auto cmd = commandsAfter[cmdAfterIdx];
						printf("Sending PART C command AFTER %s: 0x%x=0x%x\n", cmd.name, cmd.key, cmd.value);
						int buf[] = {0xf00040, 0x0000f7};
						buf[0] = buf[0] | (0x72 << 8);
						buf[1] = buf[1] | ((cmd.key % 0x80) << 16) | (cmd.value << 8);
						periph.getHDI08().writeRX(buf, 2);
						cmdAfterIdx++;
					} else {
						ready = true;
						go = true;
						bank = 0;
						param = 0;
					}
				}
			}
		}

		// Send page A & B
		if (ready) {
			if ((ctr % 50) == 0) {
				if (bank <= 1) {
					int cmd = 0x70 + bank;
					int buf[] = {0xf00040, 0x0000f7};
					const int value = values[param];
					buf[0] = buf[0] | (cmd << 8);
					buf[1] = buf[1] | ((param % 0x80) << 16) | (value << 8);
					printf("Sending UPDATED parameter BANK=0x%x KEY=0x%x VALUE=0x%x..\n", cmd, param % 0x80, value);
					periph.getHDI08().writeRX(buf, 2);
					if ((param % 0x80) == 0x7f) {
						printf("INCREASING!!!\n");
						bank++;
						param++;
					}
					param++;
				} else {
					superFinal = true;
				}
			}
		}

		// SEND MIDI
		if (superFinal && (ctr % 1000) == 0) {
			printf("Superfinal!!!");

//			int data[3] = {0x903c7f};
			int data[3] = {0x901f7f};
			periph.getHDI08().writeRX(data, 1);
			midisent = true;
		}

		//
		// END
		//

//		if (tosend && !periph.getHDI08().hasDataToSend())
//		{
//			LOG("Sending! " << tosend);
//			periph.getHDI08().setHostFlags(1, 1);
//			int s=tosend;if (s>32) s=32;
//			periph.getHDI08().writeRX(initpatch+off,s);
//			off+=s;
//			tosend-=s;
//			if (!tosend) LOG("Sent!");
//		}
		
		if((ctr & 0xfff) == 0)
		{
			LOG("Deliver Audio");
			dsp.logSC("audio");
		}

		periph.getEsai().processAudioInterleaved(audioIn, audioOut, sampleCount, channelsIn, channelsOut);

		if(!hFile && go)
		{
			for(auto c=0; c<channelsOut; ++c)
			{
				for(auto i=0; i<sampleCount; ++i)
				{
					if(audioOut[c][i] != 0.0f)
					{
						hFile = fopen("virus_out.raw", "wb");
					}
				}
			}
		}

		if(hFile)
		{
			for(auto i=0; i<sampleCount; ++i)
			{
				for(auto c=0; c<1; ++c)
					fwrite(&audioOut[c][i], sizeof(float), 1, hFile);
			}
		}
	}

	return 0;
}
