#include <iostream>
#include <vector>

#include "../dsp56300/source/dsp56kEmu/dsp.h"
#include "../dsp56300/source/dsp56kEmu/dspthread.h"
#include "../dsp56300/source/dsp56kEmu/jitunittests.h"
#include "../dsp56300/source/dsp56kEmu/unittests.h"

#include "../synthLib/wavWriter.h"
#include "../synthLib/os.h"

#include "../virusLib/romfile.h"
#include "../virusLib/microcontroller.h"
#include "../virusLib/midiOutParser.h"

using namespace dsp56k;
using namespace virusLib;
using namespace synthLib;

std::vector<uint8_t> audioData;
std::string audioFilename;

WavWriter writer;
#if _DEBUG
size_t g_writeBlockSize = 8192;
#else
size_t g_writeBlockSize = 65536;
#endif
size_t g_nextWriteSize = g_writeBlockSize;

Microcontroller::TPreset preset;
Microcontroller* microcontroller = nullptr;

size_t audioCallbackCount = 0;

void writeWord(const TWord _word)
{
	const auto d = reinterpret_cast<const uint8_t*>(&_word);
	audioData.push_back(d[0]);
	audioData.push_back(d[1]);
	audioData.push_back(d[2]);
}

void audioCallback(dsp56k::Audio* audio)
{
	switch (audioCallbackCount)
	{
	case 1:
		LOG("Sending Init Control Commands");
		microcontroller->sendInitControlCommands();
		break;
	case 128:
		LOG("Sending Preset");
		{
//			std::vector<uint8_t> data = {0xf0,0x00,0x20,0x33,0x01,0x00,0x10,0x00,0x40,0x07,0x01,0x00,0x0c,0x63,0x00,0x06,0x7f,0x06,0x00,0x40,0x7f,0x00,0x00,0x00,0x00,0x00,0x7f,0x3d,0x00,0x40,0x60,0x7f,0x3c,0x00,0x40,0x2a,0x00,0x00,0x40,0x40,0x60,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x40,0x00,0x40,0x0c,0x0c,0x7f,0x7f,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x03,0x00,0x7f,0x00,0x40,0x7f,0x00,0x7f,0x00,0x40,0x19,0x00,0x00,0x00,0x5f,0x01,0x00,0x00,0x40,0x5a,0x00,0x40,0x40,0x40,0x40,0x40,0x66,0x01,0x00,0x00,0x40,0x6e,0x00,0x40,0x40,0x40,0x40,0x40,0x58,0x01,0x40,0x00,0x00,0x00,0x02,0x71,0x7f,0x40,0x00,0x01,0x00,0x00,0x00,0x45,0x10,0x7f,0x40,0x01,0x00,0x02,0x65,0x5c,0x20,0x60,0x03,0x01,0x40,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x5c,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x39,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,0x01,0x42,0x3e,0x01,0x00,0x01,0x01,0x01,0x24,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x01,0x40,0x40,0x28,0x2b,0x55,0x40,0x40,0x40,0x40,0x1a,0x1d,0x40,0x68,0x68,0x40,0x40,0x00,0x00,0x40,0x40,0x05,0x01,0x07,0x75,0x4b,0x03,0x1c,0x1d,0x19,0x26,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x07,0x7f,0x0c,0x7f,0x00,0x03,0x00,0x24,0x70,0x30,0x40,0x7f,0x00,0x40,0x60,0x33,0x40,0x40,0x28,0x20,0x00,0x00,0x00,0x00,0x03,0x00,0x40,0x03,0x00,0x40,0x03,0x00,0x40,0x43,0x6f,0x6d,0x6d,0x65,0x72,0x73,0x65,0x53,0x56,0x00,0x01,0x07,0x00,0x00,0x00,0x3c,0xf7};

			// TI Snow Factory Preset 0 in Bank A 
			std::vector<uint8_t> data = {0xf0,0x00,0x20,0x33,0x01,0x10,0x10,0x00,0x40,0x08,0x20,0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x40,0x60,0x3c,0x00,0x00,0x40,0x46,0x00,0x00,0x40,0x40,0x60,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x40,0x1c,0x40,0x08,0x08,0x7f,0x7f,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x00,0x42,0x7f,0x00,0x3f,0x74,0x41,0x29,0x00,0x00,0x00,0x30,0x03,0x00,0x00,0x7f,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x5e,0x02,0x01,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x6a,0x00,0x40,0x00,0x00,0x00,0x00,0x30,0x7f,0x40,0x00,0x01,0x00,0x00,0x00,0x45,0x10,0x7f,0x40,0x01,0x00,0x08,0x44,0x51,0x63,0x06,0x02,0x01,0x1d,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x30,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x47,0x04,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x42,0x3e,0x01,0x00,0x01,0x01,0x01,0x24,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x01,0x40,0x40,0x28,0x2b,0x55,0x40,0x40,0x40,0x40,0x0c,0x48,0x11,0x69,0x40,0x40,0x40,0x00,0x00,0x40,0x40,0x01,0x05,0x07,0x36,0x20,0x00,0x18,0x40,0x00,0x40,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x03,0x00,0x24,0x70,0x30,0x40,0x7f,0x00,0x40,0x47,0x33,0x40,0x40,0x28,0x20,0x00,0x00,0x00,0x00,0x03,0x18,0x1c,0x05,0x2d,0x49,0x03,0x00,0x40,0x41,0x6c,0x6c,0x52,0x6f,0x75,0x6e,0x64,0x58,0x4d,0x00,0x05,0x00,0x00,0x00,0x02,0x29,0x00,0x01,0x00,0x02,0x50,0x14,0x31,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x19,0x2a,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x1f,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0xf7};
			std::vector<synthLib::SMidiEvent> responses;
			microcontroller->sendSysex(data, false, responses, MidiEventSourceEditor);
		}
//		microcontroller->writeSingle(BankNumber::EditBuffer, SINGLE, preset);
		break;
	case 512:
		LOG("Sending Note On");
		microcontroller->sendMIDI(SMidiEvent(0x90, 60, 0x7f));	// Note On
		microcontroller->sendPendingMidiEvents(std::numeric_limits<uint32_t>::max());
		break;
	}

	++audioCallbackCount;
	
	static FILE *hFile=0;
	static int ctr=0;
	constexpr size_t sampleCount = 4;
	constexpr size_t channelsIn = 2;
	constexpr size_t channelsOut = 2;

	TWord inputData[channelsIn][sampleCount] =	{{0,0,0,0}, {0,0,0,0}};
	TWord* audioIn [channelsIn ] = {inputData[0],  inputData[1] };
	TWord outputData[channelsOut][sampleCount] ={{0, 0,   0,    0},	{0, 0,   0,    0}};
	TWord* audioOut[channelsOut] = {outputData[0], outputData[1]};

	
	ctr++;
	if((ctr & 0x1fff) == 0)
	{
		LOG("Deliver Audio");
	}

	audio->processAudioInterleaved(audioIn, audioOut, sampleCount, channelsIn, channelsOut);

	if(!audioData.capacity())
	{
		for(int c=0; c<channelsOut; ++c)
		{
			for(int i=0; i<sampleCount; ++i)
			{
				if(audioOut[c][i])
				{
					audioData.reserve(2048);
				}
			}
		}

		if(audioData.capacity())
		{
			audioFilename = ROMFile::getSingleName(preset);

			for(size_t i=0; i<audioFilename.size(); ++i)
			{
				if(audioFilename[i] == ' ')
					audioFilename[i] = '_';
			}
			audioFilename = "virusEmu_" + audioFilename + ".wav";
			LOG("Begin writing audio to file " << audioFilename);
		}
	}

	if(audioData.capacity())
	{
		for(int i=0; i<sampleCount; ++i)
		{
			for(int c=0; c<2; ++c)
				writeWord(audioOut[c][i]);
		}

		if(audioData.size() >= g_nextWriteSize)
		{
			if(writer.write(audioFilename, 24, false, 2, 12000000/256, audioData))
			{
				audioData.clear();
				g_nextWriteSize = g_writeBlockSize;
			}
			else
				g_nextWriteSize += g_writeBlockSize;
		}
	}
}

void loadSingle(ROMFile& r, int b, int p)
{
	r.getSingle(b, p, preset);
}

bool loadSingle(ROMFile& r, const std::string& _preset)
{
	auto isDigit = true;
	for(size_t i=0; i<_preset.size(); ++i)
	{
		if(!isdigit(_preset[i]))
		{
			isDigit = false;
			break;
		}
	}

	if(isDigit)
	{
		int preset = atoi(_preset.c_str());
		const int bank = preset / 128;
		preset -= bank * 128;
		loadSingle(r, bank, preset);
		return true;
	}

	for(uint32_t b=0; b<8; ++b)
	{
		for(uint32_t p=0; p<128; ++p)
		{
			virusLib::Microcontroller::TPreset data;
			r.getSingle(b, p, data);

			const std::string name = ROMFile::getSingleName(data);
			if(name.empty())
			{
				return false;				
			}
			if(name == _preset)
			{
				loadSingle(r, b, p);
				return true;
			}
		}
	}
	return false;
}

auto waitReturn = []()
{
	std::cin.ignore();
};

int main(int _argc, char* _argv[])
{
	if(true)
	{
		try
		{
			puts("Running Unit Tests...");
			//		UnitTests tests;
			JitUnittests jitTests;
			//		return 0;
			puts("Unit Tests finished.");
		}
		catch(const std::string& _err)
		{
			std::cout << "Unit test failed: " << _err << std::endl;
			waitReturn();
			return -1;
		}
	}

	// Create the DSP with peripherals
	constexpr TWord g_memorySize = 0x100000;	// 128k words beginning at 0x20000
	const DefaultMemoryValidator memoryMap;
	Memory memory(memoryMap, g_memorySize);
	memory.setExternalMemory(0x020000, true);
	Peripherals56362 periph;
	DSP dsp(memory, &periph, &periph);

	periph.getEsai().setCallback(audioCallback,4,1);
	periph.getEsai().writeEmptyAudioIn(4, 2);

	const auto romFile = findROM(1024 * 1024);
	if(romFile.empty())
	{
		std::cout << "Unable to find ROM. Place a ROM file with .bin extension next to this program." << std::endl;
		waitReturn();
		return -1;
	}
	ROMFile v(romFile);
	auto loader = v.bootDSP(dsp, periph);

	if(_argc > 1)
	{
		if(!loadSingle(v, _argv[1]))
		{
			std::cout << "Failed to find preset '" << _argv[1] << "', make sure to use a ROM that contains it" << std::endl;
			waitReturn();
			return -1;
		}
	}
	else
	{
//		loadSingle(v, 3, 0x65);		// SmoothBsBC
//		loadSingle(v, 0, 12);		// CommerseSV
//		loadSingle(v, 0, 23);		// Digedi_JS
//		loadSingle(v, 0, 69);		// Mystique
//		loadSingle(v, 1, 4);		// Backing
//		loadSingle(v, 0, 50);		// Hoppin' SV
//		loadSingle(v, 0, 28);		// Etheral SV
//		loadSingle(v, 1, 75);		// Oscar1 HS
//		loadSingle(v, 0, 93);		// RepeaterJS
//		loadSingle(v, 0,126);
//		loadSingle(v, 3,101);
//		loadSingle(v, 0,5);
//		loadSingle(v, 3, 56);		// Impact  MS
//		loadSingle(v, 3, 73);		// NiceArp JS
		loadSingle(v, 0, 51);		// IndiArp BC
//		loadSingle(v, 0, 103);		// SilkArp SV
//		loadSingle(v, 3, 15);		// BellaArpJS
//		loadSingle(v, 3, 35);		// EnglArp JS
//		loadSingle(v, 3, 93);		// Rhy-Arp JS
//		loadSingle(v, 3, 119);		// WalkaArpJS
//		loadSingle(v, 0, 126);		// Init
	}
	// Load preset

	Microcontroller uc(periph.getHDI08(), v);
	microcontroller = &uc;

	dsp.enableTrace((DSP::TraceMode)(DSP::Ops | DSP::Regs | DSP::StackIndent));

	DSPThread dspThread(dsp);

	MidiOutParser midiOut;
	
	std::thread midiThread([&]() 
	{
		while(true)
		{
			const auto word = periph.getHDI08().readTX();
			midiOut.append(word);
		}
	});

	// queue for HDI08
	loader.join();
//	microcontroller->sendInitControlCommands();

	// dump memory to files
//	memory.saveAsText((romFile + "_X.txt").c_str(), MemArea_X, 0, memory.size());
//	memory.saveAsText((romFile + "_Y.txt").c_str(), MemArea_Y, 0, memory.size());
//	memory.saveAssembly((romFile + "_P.asm").c_str(), 0, memory.size(), true, false, &periph);

	while (true)
	{
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}

	return 0;
}
