#include <iostream>
#include <vector>

#include "../dsp56300/source/dsp56kEmu/dsp.h"
#include "../dsp56300/source/dsp56kEmu/dspthread.h"
#include "../dsp56300/source/dsp56kEmu/jitunittests.h"
#include "../dsp56300/source/dsp56kEmu/interpreterunittests.h"

#include "../synthLib/os.h"

#include "../virusLib/romfile.h"
#include "../virusLib/microcontroller.h"
#include "../virusLib/midiOutParser.h"

#include "esaiListener.h"

using namespace dsp56k;
using namespace virusLib;
using namespace synthLib;

Microcontroller::TPreset preset;

Microcontroller* microcontroller = nullptr;

void audioCallback(EsaiListener*, uint32_t audioCallbackCount)
{
	switch (audioCallbackCount)
	{
	case 1:
		LOG("Sending Init Control Commands");
		microcontroller->sendInitControlCommands();
		break;
	case 256:
		LOG("Sending Preset");
		{
			std::vector<uint8_t> data =
			{
				0xf0,0x00,0x20,0x33,0x01,0x10,0x10,0x01,0x7d,0x08,0x00,0x01,0x79,0x03,0x00,0x00,0x7f,0x00,0x00,0x40,0x7f,0x00,0x00,0x00,0x00,0x00,0x7f,0x40,0x00,0x40,0x60,0x7f,0x40,0x00,0x34,0x20,0x00,0x00,0x40,0x40,0x60,0x00,0x16,0x00,0x00,0x40,0x00,0x00,0x40,0x54,0x40,0x14,0x14,0x16,0x16,0x50,0x50,0x18,0x00,0x00,0x00,0x01,0x00,0x53,0x7b,0x00,0x40,0x7f,0x44,0x7e,0x6f,0x40,0x58,0x00,0x00,0x00,0x30,0x01,0x00,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x30,0x01,0x00,0x00,0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x54,0x6e,0x00,0x40,0x00,0x00,0x00,0x01,0x5f,0x36,0x40,0x00,0x01,0x00,0x00,0x34,0x53,0x33,0x42,0x40,0x01,0x00,0x01,0x3b,0x40,0x53,0x00,0x0c,0x01,0x40,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x60,0x01,0x00,0x00,0x01,0x31,0x0f,0x00,0x00,0x4d,0x04,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x01,0x42,0x3e,0x01,0x00,0x01,0x01,0x01,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x21,0x40,0x46,0x2b,0x55,0x41,0x3f,0x40,0x40,0x40,0x22,0x2b,0x50,0x50,0x41,0x41,0x00,0x00,0x48,0x40,0x09,0x0a,0x18,0x18,0x48,0x0b,0x14,0x60,0x00,0x40,0x0c,0x10,0x7f,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x05,0x06,0x19,0x49,0x30,0x40,0x00,0x00,0x40,0x47,0x33,0x53,0x40,0x28,0x20,0x00,0x00,0x00,0x00,0x0d,0x66,0x5d,0x13,0x19,0x56,0x03,0x18,0x24,0x57,0x69,0x64,0x65,0x50,0x61,0x64,0x20,0x4d,0x53,0x40,0x03,0x00,0x00,0x00,0x02,0x6d,0x00,0x01,0x00,0x03,0x6a,0x03,0x40,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x40,0x64,0x01,0x40,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0xf7
			};

			data[7] = 0x00;	// edit buffer
			data[8] = 0x40;	// SINGLE
			std::vector<SMidiEvent> responses;
			microcontroller->sendSysex(data, false, responses, MidiEventSourceEditor);
		}

//		microcontroller->writeSingle(BankNumber::EditBuffer, SINGLE, preset);
		break;
	case 512:
		LOG("Sending Note On");
		microcontroller->sendMIDI(SMidiEvent(0x90, 60, 0x7f));	// Note On
		microcontroller->sendPendingMidiEvents(std::numeric_limits<uint32_t>::max());
		break;
	case 8000:
		LOG("Sending 2nd Note On");
		microcontroller->sendMIDI(SMidiEvent(0x90, 67, 0x7f));	// Note On
		microcontroller->sendPendingMidiEvents(std::numeric_limits<uint32_t>::max());
		break;
	case 16000:
		LOG("Sending 3rd Note On");
		microcontroller->sendMIDI(SMidiEvent(0x90, 63, 0x7f));	// Note On
		microcontroller->sendPendingMidiEvents(std::numeric_limits<uint32_t>::max());
		break;
	}
}

void loadSingle(const ROMFile& r, int b, int p)
{
	r.getSingle(b, p, preset);
}

bool loadSingle(const ROMFile& r, const std::string& _preset)
{
	auto isDigit = true;
	for(size_t i=0; i<_preset.size(); ++i)
	{
		if(!isdigit(_preset[i]))
		{
			isDigit = false;
			break;
		}
	}

	if(isDigit)
	{
		int preset = atoi(_preset.c_str());
		const int bank = preset / 128;
		preset -= bank * 128;
		loadSingle(r, bank, preset);
		return true;
	}

	for(uint32_t b=0; b<8; ++b)
	{
		for(uint32_t p=0; p<128; ++p)
		{
			virusLib::Microcontroller::TPreset data;
			r.getSingle(b, p, data);

			const std::string name = ROMFile::getSingleName(data);
			if(name.empty())
			{
				return false;				
			}
			if(name == _preset)
			{
				loadSingle(r, b, p);
				return true;
			}
		}
	}
	return false;
}

auto waitReturn = []()
{
	std::cin.ignore();
};

int main(int _argc, char* _argv[])
{
	if(true)
	{
		try
		{
			puts("Running Unit Tests...");
			InterpreterUnitTests tests;
//			JitUnittests jitTests;
			puts("Unit Tests finished.");
		}
		catch(const std::string& _err)
		{
			std::cout << "Unit test failed: " << _err << std::endl;
			waitReturn();
			return -1;
		}
	}

	// Create the DSP with peripherals
	constexpr TWord g_memorySize = 0x100000;	// 128k words beginning at 0x20000
	const DefaultMemoryValidator memoryMap;
	Memory memory(memoryMap, g_memorySize);
	memory.setExternalMemory(0x020000, true);
	Peripherals56367 periphY;
	Peripherals56362 periphX(&periphY);
	DSP dsp(memory, &periphX, &periphY);

	const auto romFile = findROM(1024 * 1024);
	if(romFile.empty())
	{
		std::cout << "Unable to find ROM. Place a ROM file with .bin extension next to this program." << std::endl;
		waitReturn();
		return -1;
	}
	ROMFile v(romFile);
	auto loader = v.bootDSP(dsp, periphX);

	if(_argc > 1)
	{
		if(!loadSingle(v, _argv[1]))
		{
			std::cout << "Failed to find preset '" << _argv[1] << "', make sure to use a ROM that contains it" << std::endl;
			waitReturn();
			return -1;
		}
	}
	else
	{
//		loadSingle(v, 3, 56);		// Impact  MS
		loadSingle(v, 0, 51);		// IndiArp BC
	}

	Microcontroller uc(periphX.getHDI08(), v);
	microcontroller = &uc;

//	dsp.enableTrace((DSP::TraceMode)(DSP::Ops | DSP::Regs | DSP::StackIndent));

	std::string audioFilename = ROMFile::getSingleName(preset);

	for (size_t i = 0; i < audioFilename.size(); ++i)
	{
		if (audioFilename[i] == ' ')
			audioFilename[i] = '_';
	}
	audioFilename = "virusEmu_" + audioFilename + ".wav";

	EsaiListener esaiListener(periphX.getEsai(), audioFilename, 0b001, audioCallback);
	EsaiListener esaiListener1(periphY.getEsai(), "virusEmu_ESAI_1.wav", 0b100, [](EsaiListener*, uint32_t){});

	DSPThread dspThread(dsp);

	MidiOutParser midiOut;
	
	std::thread midiThread([&]() 
	{
		while(true)
		{
			const auto word = periphX.getHDI08().readTX();
			midiOut.append(word);
		}
	});

	// queue for HDI08
	loader.join();
//	microcontroller->sendInitControlCommands();

	// dump memory to files
//	memory.saveAsText((romFile + "_X.txt").c_str(), MemArea_X, 0, memory.size());
//	memory.saveAsText((romFile + "_Y.txt").c_str(), MemArea_Y, 0, memory.size());
//	memory.saveAssembly((romFile + "_P.asm").c_str(), 0, memory.size(), true, false, &periph);

	while (true)
	{
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}

	return 0;
}
